import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import java_cup.runtime.Symbol;
//los import están mal

//init code?
init with {:
    public static void main(String[] args) throws Exception {
//me falta todo lo anterior de initcode
        PLXC.out.println("  error;");
        PLXC.out.println("  halt;");
        done_parsing();
    }
:}

action code {:
    TablaSimbolos tabla =new TablaSimbolos();
    int bloqueActual=0;
    int cBloque = 0;
:}

/*Terminales */
terminal        A_LLAVE, C_LLAVE, PCOMA, AP, CP;
terminal        CAST, COMA, AC, CC;
terminal        IF, ELSE, WHILE, DO, FOR, PRINT, TO, DOWNTO, STEP, INT, FLOAT, CHAR;
terminal Integer ENTERO CARACTER;
terminal Double REAL;
terminal String IDENT;

//operadores
terminal        MAS, MENOS, MULT, DIVID, ASIGNA;
terminal        MENOR, MENORIG, IGUAL, DIST, MAYOR, MAYORIG;
terminal        AND, OR, NOT, DIFERENTE, YLOG, OLOG;
terminal        ADMIR, MENOSUNARIO, MASMAS, MENOSMENOS;
terminal        PORCENT, VIRGU, CAST;

/*No terminales */
//faltan mas //PRIMERA CLASE PRIMERA VERSION JUEVES 5
non terminal Sentencia, Expresion, Paso, Var_for, Array, Lista_exp, Direccion_for, List_declar_var,
non terminal Integer Inicio_bloque;
non terminal String  OperadorB, OperadorU, OperadorL;
non terminal        ExpTipo;
non terminal        Literal;

/*No terminales */
//SEGUNDA VERSIÓN MARTES 10
non terminal Bloque         Lista_de_sent; 
non terminal ListaVar       List_declar_var; //Inicio_forc, cierre_forc...todos los de arrays
non terminal Instruccion    Sentencia, Expresion, Inicio_forc, Cond_forc, Act_forc;
non terminal                Paso, Var_for, Array, Lista_exp, Direccion_for;
non terminal Integer        Inicio_bloque;
non terminal String         OperadorB, OperadorU, OperadorA, OperadorM, OperadorPost;
non terminal Tipo           ExpTipo;
non terminal Literal        Literal;

/*precedence*/ //todo bien precedence
precedence left     ELSE;
precedence left     COMA;
precedence right    ASIGNA;
precedence left     OLOG;
precedence left     YLOG;
precedence nonassoc ADMIR; //(exclamacion de not) //el lo pone debajo de mult divid porcent y con left
precedence left     IGUAL, DIFERENTE, MAYOR, MENOR, MAYORIG, MENORIG;
precedence left     MAS, MENOS;
precedence left     MULT, DIVID, PORCENT; //left
precedence nonassoc CAST; //el no pone cast
precedence nonassoc MENOSUNARIO, MASMAS, MENOSMENOS; //left


/*gramatica */ //el tiene otra nueva que ha  cvcambiado

Lista_de_sent ::= Sentencia:s
                    {:
                        Bloque b=new Bloque {PLXC.lex.getLine()};
                        b.add(s);
                        RESULT=b;
                    :}
                | Lista_de_sent:l Sentencia:s
                    {:
                        l.add(s);
                        RESULT=l;    
                    :}
                ;

Sentencia ::=   List_declar_var:l PCOMA {:RESULT = l;:}
                | Expresion:e PCOMA     {:RESULT = e;:}
                | IF AP Expresion:c CP Sentencia:sT {:RESULT = new SentIF(PLXC.lex.getLine(),c,sT,null);:}
                | IF AP Expresion:c CP Sentencia:sT ELSE Sentencia:sF{:RESULT = new SentIF(PLXC.lex.getLine(),c,sT,sF);:}
                | WHILE AP Expresion:c CP Sentencia:s {:RESULT = new SentWHILE(PLXC.lex.getLine(),c,s);:}
                | DO Sentencia:s WHILE AP Expresion:c CP PCOMA {:RESULT = new SentDOWHILE(PLXC.lex.getLine(),c,s);:}
                | FOR Inicio_bloque AP Inicio_forc:i PCOMA Cond_forc:c PCOMA //falta algo Act_forc CP Sentencia
                {:
                    bloqueActual=b;
                    RESULT = new SentFORC(PLXC.lex.getLine(),i,c,a,s);
                :}
                | PRINT AP Expresion:e CP PCOMA //habra que ver si llevarnoslo a  expresion y return void
                {:RESULT = new LlamadaMetodo(PLXC.lex.getLine(),e, //algo);:}
                | A_LLAVE Inicio_bloque:b Lista_de_sent:l C_LLAVE 
                    {: 
                        //hay que eliminar las variables de ese bloque, de la tabla, y volver al bloque anterior
                        bloqueActual = b; //con esto vuelvo al bloque anterior
                        //tabla.eliminarBloque(bloqueActual);
                        RESULT=l;
                        
                    :}
                |A_LLAVE C_LLAVE 
// Es la inst de no hacer nada, habra q devolver algo q no sea null
//for de pascal |FOR Var_for:v ASIGNA Expresion:ei Direccion_for:d Expresion:ef  //CP paso Sentencia
            ;

Inicio_bloque ::=   {: 
                        RESULT = bloqueActual; //
                        cBloque++;
                        //bloqueActual = cBloque;
                    :}
                ;


/*                     
//para pascal las reglas de:  var_for Paso y el Direcciones_for 

Inicio_forc ::=  List_declar_var:l (:RESULT=l;:)
            | Expresion:e           (:RESULT=e;:)
            |                       (:RESULT=null;:)
            ;

Cond_forc ::=  Expresion:e           (:RESULT=e;:)
            |                       (:RESULT=null;:)
            ;

Act_forc ::=  Expresion:e           (:RESULT=e;:)
            |                       (:RESULT=null;:)
            ;
               
Var_for ::=  IDENT:i
            ;

Paso ::= STEP Expresion:e
            | 
            ;

Direccion_for ::= TO
                | DOWNTO
                ;
*/
         
Else_if ::= ELSE Sentencia
            | PCOMA
            ;

List_declar_var ::= ExpTipo:t IDENT:i 
                        {:tabla.declararVariable(i, bloqueActual, true, t);
                        RESULT = new ListaVar(PLXC.lex.getLine(), t);:}

                    |ExpTipo:t IDENT:i AC ENTERO:e CC 

                    |ExpTipo:t IDENT:i ASIGNA Expresion:e
                        {:  
                            Variable v = tabla.declararVariable(i, bloqueActual, true, t);
                            ListaVar l = new ListaVar(PLXC.lex.getLine(), t);
                            l.add(new LlamadaMetodo(PLXC.lex.getLine(),
                                        new ExpVariable(PLXC.lex.getLine(), v),
                                        Metodos.CONSTRUCTORCOPIA,
                                        new Instruccion []{e}));

                            RESULT=l;
                        :}
                    |ExpTipo:t IDENT:i AC ENTERO:e CC ASIGNA Array:e

                    |List_declar_var:t COMA IDENT:i
                    {://carlos lo tiene:}

                    |List_declar_var:t COMA IDENT:i AC ENTERO:e CC

                    |List_declar_var:t COMA IDENT:i ASIGNA Expresion:e
                    {:
                        Variable v = tabla.declararVariable(i, bloqueActual, true, t.getTipo());
                        //lista.add lo tiene carlos

                        RESULT=l;
                    :}
                    |List_declar_var:t COMA IDENT:i AC ENTERO:e CC ASIGNA Array:e
                    ;

Array ::= IDENT:i 
        | A_LLAVE Lista_exp:e C_LLAVE
        ;

Lista_exp ::= Expresion:e
        |Lista_exp:l COMA Expresion:e 
        ;

//para reconocer los tipos de datos
ExpTipo ::= INT     {RESULT = TipoInt.instancia;}
        |CHAR       {RESULT = TipoChar.instancia;}
        |FLOAT      {RESULT = TipoReal.instancia;}
        ;

Expresion ::= Literal:l {: RESULT = new ExpLiteral(PLXC.lex.getline, l):}

            |IDENT:i    {: Objeto o = tabla.buscarObjeto(i); if ((o == null)||!(o instanceof Variable)){ throw new ParseException("Variable ("+i+") no definida", PLXC.lex.getline)} RESULT = new ExpVariable(PLXC.lex.getline(), (Variable) o):}

            |Expresion:e1 ASIGNA Expresion:e2
                (:
                RESULT=new LlamadaMetodo(PLXC.lex.getLine(),
                                        e1,
                                        Metodos.ASIGNA,
                                        new Instancia new Instruccion[]{e2});
                
                :)

            |Expresion:e1 OperadorB Expresion:e2 {: RESULT = new LlamadaMetodo(PLXC.lex.getLine(), e1, o, new Instruccion[]{e2});:}

            |Expresion:e1 OperadorA Expresion:e2 {: RESULT = // no es entero asi new LlamadaMetodo(PLXC.lex.getLine(), e1, o, new Instruccion[]{e2});:}

            |Expresion:e1 OperadorM Expresion:e2 {: RESULT = // no es entero así new LlamadaMetodo(PLXC.lex.getLine(), e1, o, new Instruccion[]{e2});:}

            |Expresion:e1 OLOG Expresion:e2  {: RESULT = new Cortocircuito(PLXC.lex.getLine(), e1, Metodos.OLOG,  e2;):}

            |Expresion:e1 YLOG Expresion:e2  {: RESULT = new Cortocircuito(PLXC.lex.getLine(), e1, Metodos.YLOG,  e2;):}

            |OperadorU Expresion:e {: RESULT = new LlamadaMetodo(PLXC.lex.getLine(), e, o, null);:} %prec MENOSUNARIO

            |AP Expresion:e CP {:RESULT = e;:}

            |Expresion:i MASMAS //lo mimo  pero con CopiaYllamadametodo

            |Expresion:i MENOSMENOS

            |AP ExpTipo:t CP Expresion:e {: var et = new ExpTipo (PLXC.lex.getLine(), t); RESULT = new LlamadaMetodo(PLXC.lex.getLine(), e, METODOS.CAST,  new Instruccion[]{et});:} %prec CAST
            ; // carlos  foto 17 dic  de ident, asigna y olog

OperadorB ::= ASIGNA    {: RESULT= Metodos.ASIGNA; :}
            |MAS        {: RESULT= Metodos.SUMA; :}
            |MENOS      {: RESULT= Metodos.RESTA; :}
            |MULT       {: RESULT= Metodos.MULT; :}
            |DIVID      {: RESULT= Metodos.DIVID; :}
            |IGUAL      {: RESULT= Metodos.IGUAL; :}
            |DIFERENTE  {: RESULT= Metodos.DIFERENTE; :}
            |MENOR      {: RESULT= Metodos.MENOR; :}
            |MENORIG    {: RESULT= Metodos.MENORIG; :}
            |MAYOR      {: RESULT= Metodos.MAYOR; :}
            |MAYORIG    {: RESULT= Metodos.MAYORIG; :}
            |PORCENT    {: RESULT= Metodos.RESTO; :}
            ;

OperadorL ::= YLOG       {: RESULT= Metodos.YLOG; :}
            | OLOG       {: RESULT= Metodos.OLOG; :}
            ;

Literal ::= ENTERO:e {:RESULT = new Literal (bloqueActual, TipoInt.Instancia, e):}
        | CARACTER:c 
        | REAL:r //no estoy seguro de que sea asi
        //falta otro 
        ;

//ej.plx codigo fuente
//MiCompilador genera un ej.ctd
//ctd es el que transforma mi ej.ctd , genera una salida
//dicha salida tiene que generar lo mismo que el plxc(compilador) del profesor con ctd.


OperasdorR igual diferente menor menorIG mayor mayorig

OperadorA ::= MAS {:RESULT= Metodos.SUMA; :}
            |MENOS {:RESULT= Metodos.RESTA:} 

OperadorM::= MULT {:RESULT= Metodos.MULT; :}
            |DIVID {:RESULT= Metodos.DIVID:} 
            |PORCENT {:RESULT= Metodos.RESTO:}
            ;
Operador U::= MASMAS {:RESULT= Metodos.SIGUIENTE; :}
            |MENOSMENOS {:RESULT= Metodos.ANTERIOR:} 
            |VIRGU
            | MENOS {:RESULT= Metodos.OPUESTO:}
            ;

OperadorUPost::= MASMAS {:RESULT=Metodos.SIGUIENTE;:}
//faltan





//  le falta de arrays al rpofesor por implementar:
//    int a[3] = {1,2,3};
//    a = {3,4,5};
//